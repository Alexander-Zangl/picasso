#!/usr/bin/env python
"""
    picasso.__main__
    ~~~~~~~~~~~~~~~~

    Picasso command line interface

    :author: Joerg Schnitzbauer, 2015
"""


import sys
import os.path

_this_file = os.path.abspath(__file__)
_this_directory = os.path.dirname(_this_file)
_parent_directory = os.path.dirname(_this_directory)
sys.path.insert(0, _parent_directory)    # We want to use the local picasso instead the system-wide


def _link(files, radius, tolerance):
    import glob
    paths = glob.glob(files)
    if paths:
        from picasso import io, postprocess
        for path in paths:
            locs, info = io.load_locs(path)
            linked_locs = postprocess.link(locs, radius, tolerance)
            base, ext = os.path.splitext(path)
            link_info = {'Radius': radius,
                         'Maximum Transient Dark Time': tolerance,
                         'Generated by': 'Picasso Link'}
            info.append(link_info)
            io.save_locs(base + '_link.hdf5', linked_locs, info)


def _undrift(files, segmentation, display):
    import glob
    paths = glob.glob(files)
    if paths:
        from picasso import io, postprocess
        for path in paths:
            print('Undrifting file {}'.format(path))
            locs, info = io.load_locs(path)
            corrected_locs = postprocess.undrift(locs, info, segmentation, display)
            base, ext = os.path.splitext(path)
            undrift_info = {'Segmentation': segmentation,
                            'Display': display,
                            'Generated by': 'Picasso Undrift'}
            info.append(undrift_info)
            io.save_locs(base + '_undrift.hdf5', corrected_locs, info)


def _density(files, radius):
    import glob
    paths = glob.glob(files)
    if paths:
        from picasso import io, postprocess
        for path in paths:
            locs, info = io.load_locs(path)
            locs = postprocess.compute_local_density(locs, radius)
            base, ext = os.path.splitext(path)
            density_info = {'Generated by': 'Picasso Density',
                            'Radius': radius}
            info.append(density_info)
            io.save_locs(base + '_density.hdf5', locs, info)


def _dbscan(files, radius, min_density):
    import glob
    paths = glob.glob(files)
    if paths:
        from picasso import io, postprocess
        for path in paths:
            locs, info = io.load_locs(path)
            locs = postprocess.dbscan(locs, radius, min_density)
            base, ext = os.path.splitext(path)
            dbscan_info = {'Generated by': 'Picasso DBSCAN',
                           'Radius': radius,
                           'Minimum local density': min_density}
            info.append(dbscan_info)
            io.save_locs(base + '_dbscan.hdf5', locs, info)


def _dark(files):
    import glob
    paths = glob.glob(files)
    if paths:
        from picasso import io, postprocess
        for path in paths:
            locs, info = io.load_locs(path)
            locs = postprocess.compute_dark_times(locs)
            base, ext = os.path.splitext(path)
            dbscan_info = {'Generated by': 'Picasso Dark'}
            info.append(dbscan_info)
            io.save_locs(base + '_dark.hdf5', locs, info)


def _std(files):
    import glob
    paths = glob.glob(files)
    if paths:
        from picasso.io import load_raw
        from numpy import std
        from os.path import splitext
        from tifffile import imsave
        for path in paths:
            movie, info = load_raw(path)
            std_image = std(movie, axis=0, dtype='f4')
            base, ext = splitext(path)
            imsave(base + '_std.tif', std_image)


if __name__ == '__main__':
    import argparse

    # Main parser
    parser = argparse.ArgumentParser('picasso')
    subparsers = parser.add_subparsers(dest='command')

    # toraw parser
    toraw_parser = subparsers.add_parser('toraw', help='convert image sequences to binary raw files and accompanied YAML information files')
    toraw_parser.add_argument('files', help='one or multiple files specified by a unix style pathname pattern')

    # link parser
    link_parser = subparsers.add_parser('link', help='link localizations in consecutive frames')
    link_parser.add_argument('files', help='one or multiple hdf5 localization files specified by a unix style path pattern')
    link_parser.add_argument('-r', '--radius', type=float, default=1.0,
                             help='maximum distance between consecutive localization to still consider them the same binding event (default=1.0)')
    link_parser.add_argument('-t', '--tolerance', type=int, default=1,
                             help='maximum dark time between localizations to still consider them the same binding event (default=1)')

    # undrift parser
    undrift_parser = subparsers.add_parser('undrift', help='correct localization coordinates for drift')
    undrift_parser.add_argument('files', help='one or multiple hdf5 localization files specified by a unix style path pattern')
    undrift_parser.add_argument('-s', '--segmentation', type=float, default=1000,
                                help='the number of frames to be combined for one temporal segment (default=1000)')
    undrift_parser.add_argument('-d', '--nodisplay', action='store_false', help='do not display estimated drift')

    # local density
    density_parser = subparsers.add_parser('density', help='compute the local density of localizations')
    density_parser.add_argument('files', help='one or multiple hdf5 localization files specified by a unix style path pattern')
    density_parser.add_argument('radius', type=float, help='maximal distance between to localizations to be considered local')

    # DBSCAN
    dbscan_parser = subparsers.add_parser('dbscan', help='cluster localizations')
    dbscan_parser.add_argument('files', help='one or multiple hdf5 localization files specified by a unix style path pattern')
    dbscan_parser.add_argument('radius', type=float, help='maximal distance between to localizations to be considered local')
    dbscan_parser.add_argument('density', type=int, help='minimum local density for localizations to be assigned to a cluster')

    # Dark time
    dark_parser = subparsers.add_parser('dark', help='compute the dark time for grouped localizations')
    dark_parser.add_argument('files', help='one or multiple hdf5 localization files specified by a unix style path pattern')

    # STD Image
    std_parser = subparsers.add_parser('std', help='generate the std image of a raw movie')
    std_parser.add_argument('files', help='one or multiple raw files, specified by a unix style path pattern')

    # Parse
    args = parser.parse_args()
    if args.command:
        if args.command == 'toraw':
            from picasso import io
            io.to_raw(args.files, verbose=True)
        elif args.command == 'link':
            _link(args.files, args.radius, args.tolerance)
        elif args.command == 'undrift':
            _undrift(args.files, args.segmentation, args.nodisplay)
        elif args.command == 'density':
            _density(args.files, args.radius)
        elif args.command == 'dbscan':
            _dbscan(args.files, args.radius, args.density)
        elif args.command == 'dark':
            _dark(args.files)
        elif args.command == 'std':
            _std(args.files)
    else:
        parser.print_help()
